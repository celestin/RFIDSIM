<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>rfidsim: RFIDSIM -- A Simulator for RFID Networks</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li id="current"><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<h1>RFIDSIM -- A Simulator for RFID Networks</h1>
<p>
<dl compact><dt><b>Author:</b></dt><dd>Matthew J. Miller (<a href="mailto:matt@matthewjmiller.net">matt@matthewjmiller.net</a>) </dd></dl>
<dl compact><dt><b>Date:</b></dt><dd>2006 </dd></dl>
<dl compact><dt><b>Version:</b></dt><dd>0.1</dd></dl>
<h2><a class="anchor" name="sec_intro">
Introduction</a></h2>
RFIDSIM is intended to be an extensible simulator for RFID readers and tags as well as other types of wireless networks.<p>
Right now, it is in the very early stages and has not been well-tested, but hopefully it can serve as a foundation for someone looking to develop a more complete and robust RFID simulator. It is released under the GNU General Public License (<a href="http://www.gnu.org/licenses/gpl.html">http://www.gnu.org/licenses/gpl.html</a>).<h2><a class="anchor" name="sec_install">
Installation</a></h2>
<h3><a class="anchor" name="sec_install_step1">
Step 1</a></h3>
Install the Boost C++ libraries on your system (<a href="http://www.boost.org/">http://www.boost.org/</a>). I used Boost version 1.33.1 in development. In Debian, there are packages available that can be installed using <code>aptitude</code>.<h3><a class="anchor" name="sec_install_step2">
Step 2</a></h3>
Run <code>make</code>.<h3><a class="anchor" name="sec_install_step3">
Step 3</a></h3>
Modify <a class="el" href="main_8cpp-source.html">main.cpp</a> as necessary to create new scenarios.<h2><a class="anchor" name="sec_channel">
RFID Channel Model</a></h2>
Each <a class="el" href="classPhysicalLayer.html">PhysicalLayer</a> can select on which channel it transmits and receives independently. We use this to model RFID networks as follows. There is one master channel on which all readers transmit (but not receive) and all tags receive (but not transmit). Then, each reader chooses a regular channel on which packets are both send and received. Whenever a tag successfully receives a packet on the master channel, it will transmit a packet on the regular channel of the reader that sent the packet.<p>
Thus, tags are essentially listening on all channels concurrently and can experience collisions if multiple readers transmit simultaneously (even if the readers' regular channels are different). Once the tag receives a reader's packet, it locks on to that channel to transmit back the the reader. The tag's tranmission is only overheard by devices listening on the regular channel of the reader to which the packet is transmitted.<p>
As we understand it, this is the correct channel model for RFIDs. It has the important implication that readers cannot use different channels for their transmissions in order to avoid interference at tags.<p>
With respect to the transmit power, the tag is modelled as reflecting the reader's tranmit power. This is done by setting the transmit power of a tag to the received signal strength of the last packet that it received.<p>
One thing that we are <em>not</em> currently modelling is the fact that tags must have a sufficiently strong culmulative received energy or else they "turn off".<h2><a class="anchor" name="sec_advantages">
Advantages Over ns-2</a></h2>
Most of my previous development was in <code>ns-2</code> (<a href="http://nsnam.isi.edu/nsnam/">http://nsnam.isi.edu/nsnam/</a>), but developed this to give several advantages over <code>ns-2</code> (of course, there are many disadvantages as well, see <a class="el" href="index.html#sec_future_work">Future Work</a>).<p>
<ul>
<li><b>More realistic physical layer</b>: I used the Qualnet model of culmulative interference rather than <code>ns-2's</code> model of only considering the interference between two packets. Also, a <a class="el" href="classRicean.html">Ricean</a> fading model is included by default. This is based on a <code>ns-2</code> extension (<a href="http://www.ece.cmu.edu/wireless/downloads.html">http://www.ece.cmu.edu/wireless/downloads.html</a>), but improves on it by calculating the fading factor at a receiver as a function of <em>both</em> the current time <em>and</em> the specific receiver for which it is being calculated (by contrast, the <code>ns-2</code> extension only calculates the fading factor as a function of the current time).</li>
</ul>
<ul>
<li><b>Multi-interface and multi-channel support</b>: From the beginning, I tried to make it easy to connect a network layer to multiple upper or lower layers in the stack. This allows, for example, multiple physical layers (i.e., radios) per device. Also, there is a <a class="el" href="classWirelessChannelManager.html">WirelessChannelManager</a> class to handle multiple channels easier and more with more flexibility than <code>ns-2</code>.</li>
</ul>
<ul>
<li><b>Smart pointers</b>: This is my primarly motivation for using Boost because the entire project uses smart pointers (with the exception of singleton classes). This, by in large, frees the developer from worrying about memory management. Each pointer is reference counted and automatially <code>delete'd</code> whenever the count reaches zero. Thus, you'll notice there are no explicit <code>delete</code> or <code>free</code> function calls in the code. Additionally, there is no overhead for garbage collection. The disadvantage of smart pointers is that cyclic references can arise and must be dealt with using <code>weak_ptr's</code> or else a memory leak may occur. Right now, the code is simple enough that such cycles rarely occur. Another difficult is handling the <code>this</code> pointer to an object, particularly when inheritance is involved. You can peruse the code to see the approach I've taken to this problem.</li>
</ul>
<ul>
<li><b>Better use of the C++ STL</b>: I tried to use the STL wherever possible whereas <code>ns-2</code> seems to use "homegrown" data structures for the most part. For example, my event scheduler is built on the STL's <code>multimap</code>, which is very efficient, whereas <code>ns-2</code> creates its own heap for this purpose which can be more bug-prone and exposes more code to the user.</li>
</ul>
<ul>
<li><b>Better object-oriented design</b>: Of course this is subjective, but I tried to incorporate more object-oriented design techniques than I have seen in the <code>ns-2</code> wireless classes. I have used some design patterns, such as the singleton and factory method, in the project.</li>
</ul>
<ul>
<li><b>Improved random number generator</b>: I used the random number generation library from Boost, which claims industrial strength RNG. By contrast, the RNG of <code>ns-2</code> is based on the default C++ RNG, which is not as strong.</li>
</ul>
<h2><a class="anchor" name="sec_future_work">
Future Work</a></h2>
This project is far from complete and should only be used if you are interested in developing it further. Some work that would benefit this project include:<p>
<ul>
<li><b>Scripting front-end</b>: Right now, every separate scenario must be recompiled which obviously is not feasible. Some possibilities for this include: (1) using the Python/C++ interface in Boost or (2) designing a relatively simple scenario specification file that can be input and parsed by the simulator (perhaps using Boost's regex library). I do not think that SWIG (<a href="http://www.swig.org/">http://www.swig.org/</a>) would work since it has issues with C++ and probably would not work with smart pointers. IMHO, the best option is probably (2) since it would give more portability (Boost's Python library seems quite difficult to install) and easier to debug.</li>
</ul>
<ul>
<li><b>Bit error model</b>: Right now there is no bit error model. Packets are received if their SINR is larger than a statically specified capture threshold.</li>
</ul>
<ul>
<li><b> Queueing model</b>: Right now, there is a minimal queueing model, but I feel that this needs improved for experiments where queueing is a factor.</li>
</ul>
<ul>
<li><b>More protocols</b>: For RFID, a tree-walking MAC protocol would be useful. Beyond that, 802.11 and some ad hoc routing protocols would be useful for ad hoc network and wireless LAN simulations.</li>
</ul>
<ul>
<li><b>Energy model</b>: A model should be added to track the energy consumption of various commands.</li>
</ul>
<ul>
<li><b>More examples</b>: Right now, the only scenario example is that of <a class="el" href="main_8cpp-source.html">main.cpp</a>. After a scripting front-end is added, creating more examples would be useful.</li>
</ul>
<h2><a class="anchor" name="sec_license">
GNU General Public License</a></h2>
This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.<p>
This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.<p>
You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA. <hr size="1"><address style="align: right;"><small>Generated on Tue Dec 12 17:04:37 2006 for rfidsim by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
